name: Build & Pin

on:
  workflow_dispatch:
    inputs:
      processors:
        description: "Comma-separated processor package names (e.g. llm_litellm,replicate_generic). Empty = all."
        required: false
        default: ""
  push:
    branches: [dev, main]
    paths:
      - "code/apps/core/processors/**"
      - "code/apps/core/registry/processors/**"
      - ".github/workflows/build-and-pin.yml"

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  matrix:
    runs-on: ubuntu-latest
    outputs:
      processors: ${{ steps.matrix.outputs.list }}
    steps:
      - uses: actions/checkout@v4
      - name: Resolve processor matrix from registry
        id: matrix
        run: |
          python - <<'PY'
          import yaml, json, pathlib, os
          requested = (os.getenv("INPUT_PROCESSORS") or "${{ inputs.processors }}").strip()
          req = {p.strip() for p in requested.split(",") if p.strip()}
          base = pathlib.Path("code/apps/core/registry/processors")
          items = []
          # Use registry files as source of truth
          for y in sorted(base.glob("*.yaml")):
            doc = yaml.safe_load(y.read_text())
            ref = doc["ref"]                        # e.g. "llm/litellm@1"
            ns, rest = ref.split("/", 1)
            name, ver = rest.split("@", 1)
            pkg = f"{ns}_{name}"                    # e.g. "llm_litellm"
            if req and pkg not in req:
              continue
            proc_dir = f"code/apps/core/processors/{pkg}"
            dockerfile = f"{proc_dir}/Dockerfile"
            items.append({
              "ref": ref,
              "pkg": pkg,
              "proc_dir": proc_dir,
              "dockerfile": dockerfile,
              "registry_yaml": str(y)
            })
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            f.write(f"list={json.dumps(items)}\n")
          PY

  build:
    needs: matrix
    if: needs.matrix.outputs.processors != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        processor: ${{ fromJson(needs.matrix.outputs.processors) }}
    outputs:
      digests: ${{ steps.build.outputs.digests }}
    env:
      PIP_DISABLE_PIP_VERSION_CHECK: "1"
      PYTHONUNBUFFERED: "1"
      GHCR_IMAGE_PREFIX: ghcr.io/${{ github.repository }}     # repo-scoped (owner/repo)
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install helper deps
        run: |
          pip install -U pip wheel pyyaml

      - name: Docker login to GHCR
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Enable QEMU
        uses: docker/setup-qemu-action@v3

      - name: Enable Buildx
        uses: docker/setup-buildx-action@v3

      - name: Resolve processor matrix from registry
        id: matrix
        run: |
          python - <<'PY'
          import yaml, json, pathlib, os
          requested = (os.getenv("INPUT_PROCESSORS") or "${{ inputs.processors }}").strip()
          req = {p.strip() for p in requested.split(",") if p.strip()}
          base = pathlib.Path("code/apps/core/registry/processors")
          items = []
          # Use registry files as source of truth
          for y in sorted(base.glob("*.yaml")):
            doc = yaml.safe_load(y.read_text())
            ref = doc["ref"]                        # e.g. "llm/litellm@1"
            ns, rest = ref.split("/", 1)
            name, ver = rest.split("@", 1)
            pkg = f"{ns}_{name}"                    # e.g. "llm_litellm"
            if req and pkg not in req:
              continue
            proc_dir = f"code/apps/core/processors/{pkg}"
            dockerfile = f"{proc_dir}/Dockerfile"
            items.append({
              "ref": ref,
              "pkg": pkg,
              "proc_dir": proc_dir,
              "dockerfile": dockerfile,
              "registry_yaml": str(y)
            })
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            f.write(f"list={json.dumps(items)}\n")
          PY

      - name: Fail if no processors found
        if: steps.matrix.outputs.list == '[]'
        run: |
          echo "::error::No processors resolved for build."
          exit 1

      - name: Build & push (multi-arch) each processor
        id: builds
        env:
          LIST: ${{ steps.matrix.outputs.list }}
          GHCR_IMAGE_PREFIX: ${{ env.GHCR_IMAGE_PREFIX }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, os, subprocess
          procs = json.loads(os.environ["LIST"])
          prefix = os.environ["GHCR_IMAGE_PREFIX"]
          digests = []
          for p in procs:
            pkg = p["pkg"]
            dockerfile = p["dockerfile"]
            context = "code"                        # build context is ./code
            image_suffix = pkg.replace("_","-")     # ghcr naming (hyphen)
            tag_base = f"{prefix}/{image_suffix}"
            tag_tmp  = f"{tag_base}:build-${{ github.run_id }}"
            print(f"--- Building {pkg} -> {tag_tmp}")
            subprocess.check_call([
              "docker","buildx","build",
              "--platform","linux/amd64,linux/arm64",
              "--provenance=false","--sbom=false",
              "-f", dockerfile,
              "-t", tag_tmp,
              "--push",
              context
            ])
            out = subprocess.check_output(["docker","buildx","imagetools","inspect", tag_tmp], text=True)
            if "linux/amd64" not in out:
              raise SystemExit(f"missing linux/amd64 platform for {pkg} ({tag_tmp})")
            if "linux/arm64" not in out:
              raise SystemExit(f"missing linux/arm64 platform for {pkg} ({tag_tmp})")
            digest = None
            for line in out.splitlines():
              line=line.strip()
              if line.startswith("Digest: "):
                digest = line.split("Digest:",1)[1].strip()
                break
            if not digest:
              raise SystemExit(f"Could not determine digest for {pkg}")
            full_ref = f"{tag_base}@{digest}"
            digests.append({"pkg":pkg, "full_ref":full_ref, "registry_yaml":p["registry_yaml"]})
            print(f"✅ {pkg} => {full_ref}")
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            import json
            f.write(f"digests={json.dumps(digests)}\n")
          PY

      - name: Update registry pins
        id: pin
        run: |
          set -euo pipefail
          python - <<'PY'
          import os, json, yaml, pathlib
          changed_any = False
          data = json.loads('${{ steps.builds.outputs.digests }}')
          for item in data:
            yml = pathlib.Path(item["registry_yaml"])
            doc = yaml.safe_load(yml.read_text())
            doc.setdefault("image", {})
            current = doc["image"].get("oci", "")
            new = item["full_ref"]
            if current != new:
              doc["image"]["oci"] = new
              yml.write_text(yaml.safe_dump(doc, sort_keys=False), encoding="utf-8")
              print(f"Pinned {doc['ref']} => {new} (was {current or 'unset'})")
              changed_any = True
          if not changed_any:
            print("No registry changes needed")
          PY

      - name: Detect registry changes
        id: detect
        run: |
          if git diff --quiet -- code/apps/core/registry/processors; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Create Pin PR (idempotent)
        if: steps.detect.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "ci: pin processor images (bot)"
          branch: "bot/pin-images"
          title: "ci: pin processor images"
          body: |
            This PR pins processor images to the latest built digests.
            • Workflow: ${{ github.workflow }}  • Run: ${{ github.run_id }}
          labels: ci,automated
