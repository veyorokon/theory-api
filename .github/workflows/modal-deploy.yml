name: Modal Deploy

on:
  push:
    branches: [dev, staging, main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Modal environment override (dev|staging|main)"
        required: false
        default: ""

jobs:
  deploy:
    name: Deploy to Modal
    runs-on: ubuntu-latest
    # Map git branch to GH Environment; main -> prod, else branch name unless overridden
    environment: ${{ inputs.environment != '' && inputs.environment || (github.ref_name == 'main' && 'prod' || github.ref_name) }}
    permissions:
      contents: read
    env:
      PIP_DISABLE_PIP_VERSION_CHECK: "1"
      PYTHONUNBUFFERED: "1"
      MODAL_ENVIRONMENT: ${{ inputs.environment != '' && inputs.environment || github.ref_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          pip install -U pip wheel
          pip install -r requirements.txt
          pip install modal pyyaml

      - name: Compute required processor secrets (from registry)
        run: |
          python code/ops/list_required_secrets.py > required_secrets.json
          echo "Required secrets: $(cat required_secrets.json)"

      - name: Enforce allow-list for secret names
        run: |
          set -euo pipefail
          REQ=$(cat required_secrets.json)
          echo "$REQ" | python - <<'PY'
          import sys,json
          allow = {"OPENAI_API_KEY","REPLICATE_API_TOKEN"}
          req = json.load(sys.stdin)
          bad = [s for s in req if s not in allow]
          if bad:
            print("‚ùå Unexpected secret(s) in registry:", ", ".join(bad))
            sys.exit(1)
          print("‚úÖ Registry secrets conform to allow-list.")
          PY

      - name: Sync secrets to Modal (upsert, same names)
        env:
          MODAL_TOKEN_ID: ${{ secrets.MODAL_TOKEN_ID }}
          MODAL_TOKEN_SECRET: ${{ secrets.MODAL_TOKEN_SECRET }}
          MODAL_ENVIRONMENT: ${{ env.MODAL_ENVIRONMENT }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          REPLICATE_API_TOKEN: ${{ secrets.REPLICATE_API_TOKEN }}
        run: |
          set -euo pipefail
          modal token set --token-id "$MODAL_TOKEN_ID" --token-secret "$MODAL_TOKEN_SECRET" >/dev/null
          echo "üîê Syncing secrets to Modal env=$MODAL_ENVIRONMENT"
          python - <<'PY'
          import os, json, subprocess, sys
          req = json.load(open("required_secrets.json"))
          values = {k: os.environ.get(k,"") for k in ("OPENAI_API_KEY","REPLICATE_API_TOKEN")}
          missing = []
          for name in req:
              val = values.get(name, "")
              if not val:
                  print(f"  ‚ö†Ô∏è  Missing GitHub secret value: {name}")
                  missing.append(name)
                  continue
              print(f"  Creating/updating {name} (len={len(val)})")
              subprocess.run(
                ["modal","secret","create", name, f"{name}={val}", "--env", os.environ["MODAL_ENVIRONMENT"], "--force"],
                check=True, stdout=subprocess.DEVNULL
              )
          if missing:
              print("‚ùå Missing GitHub secret value(s):", ", ".join(missing))
              sys.exit(1)
          print("‚úÖ All required secrets present and synced.")
          PY

      - name: Deploy all processors to Modal
        working-directory: code
        env:
          MODAL_ENVIRONMENT: ${{ env.MODAL_ENVIRONMENT }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import yaml, os, subprocess, glob

          files = sorted(glob.glob("apps/core/registry/processors/*.yaml"))
          for path in files:
              doc = yaml.safe_load(open(path))
              ref = doc["ref"]
              image = doc["image"]["oci"]

              # Map secrets to processor families (extend here if needed)
              if ref.startswith("llm/"):
                  secrets = "OPENAI_API_KEY"
              elif ref.startswith("replicate/"):
                  secrets = "REPLICATE_API_TOKEN"
              else:
                  secrets = ""

              env = os.environ.copy()
              env["IMAGE_REF"] = image
              env["PROCESSOR_REF"] = ref
              env["TOOL_SECRETS"] = secrets

              print(f"\nüöÄ Deploying {ref} with image {image}")
              res = subprocess.run(
                ["modal","deploy","--env", os.environ["MODAL_ENVIRONMENT"], "-m", "modal_app"],
                env=env, capture_output=True, text=True
              )
              if res.returncode != 0:
                  print(f"‚ùå Failed to deploy {ref}\n{res.stderr}")
                  raise SystemExit(1)
              print(f"‚úÖ Deployed {ref}")
          PY

      - name: Post-deploy smoke tests (Modal adapter)
        working-directory: code
        env:
          DJANGO_SETTINGS_MODULE: backend.settings.unittest
          MODAL_ENABLED: "true"
          MODAL_ENVIRONMENT: ${{ env.MODAL_ENVIRONMENT }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import yaml, json, subprocess, glob

          files = sorted(glob.glob("apps/core/registry/processors/*.yaml"))
          for path in files:
              doc = yaml.safe_load(open(path))
              ref = doc["ref"]

              if ref.startswith("llm/"):
                  inputs = '{"schema":"v1","model":"gpt-4o-mini","params":{"messages":[{"role":"user","content":"deployment smoke test"}]},"mode":"mock"}'
              elif ref.startswith("replicate/"):
                  inputs = '{"schema":"v1","model":"black-forest-labs/flux-schnell","params":{"prompt":"test image"},"mode":"mock"}'
              else:
                  print(f"‚ö†Ô∏è Skipping unknown processor type: {ref}")
                  continue

              print(f"\nüß™ Smoke: {ref}")
              cmd = [
                "python","manage.py","run_processor",
                "--ref", ref,
                "--adapter", "modal",
                "--mode", "smoke",
                "--write-prefix", "/artifacts/outputs/smoke/{execution_id}/",
                "--inputs-json", inputs,
                "--json"
              ]
              res = subprocess.run(cmd, capture_output=True, text=True)
              if res.returncode != 0:
                  print(f"‚ùå Smoke failed for {ref}\n{res.stderr}")
                  raise SystemExit(1)
              try:
                  payload = json.loads(res.stdout)
                  assert payload.get("status") == "success", payload
                  assert payload.get("execution_id")
                  print(f"‚úÖ {ref} ok: {payload['execution_id']}")
              except Exception as e:
                  print(f"‚ùå Validation failed for {ref}: {e}\nOutput: {res.stdout}")
                  raise SystemExit(1)
          PY
