name: Modal Deploy

on:
  push:
    branches: [dev, staging, main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Modal environment override (dev|staging|main)"
        required: false
        default: ""

jobs:
  deploy:
    name: Deploy to Modal
    runs-on: ubuntu-latest
    # Map git branch to GitHub Environment; main -> prod, else branch name unless overridden
    environment: ${{ inputs.environment != '' && inputs.environment || (github.ref_name == 'main' && 'prod' || github.ref_name) }}
    permissions:
      contents: read
    env:
      PIP_DISABLE_PIP_VERSION_CHECK: "1"
      PYTHONUNBUFFERED: "1"
      MODAL_ENVIRONMENT: ${{ inputs.environment != '' && inputs.environment || github.ref_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install -U pip wheel
          pip install -r requirements.txt
          pip install modal pyyaml

      # 1) Read processors + digests from registry (already pinned)
      - name: Collect processors from registry
        id: processors
        run: |
          python - <<'PY'
          import glob, yaml, json, os
          processors = []
          for path in sorted(glob.glob("code/apps/core/registry/processors/*.yaml")):
              doc = yaml.safe_load(open(path))
              ref = doc["ref"]  # e.g., "llm/litellm@1"
              oci = doc["image"]["oci"]
              secrets = [s for s in doc.get("secrets", {}).get("required", [])]

              processors.append({
                  "ref": ref,
                  "oci": oci,
                  "secrets": secrets
              })

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"list={json.dumps(processors)}\n")

          print(f"Found {len(processors)} processors:")
          for p in processors:
              print(f"  {p['ref']} -> {p['oci']}")
              if p['secrets']:
                  print(f"    secrets: {', '.join(p['secrets'])}")
          PY

      # 2) Secret sync to Modal env (dev/staging/main)
      - name: Sync secrets to Modal
        env:
          MODAL_ENVIRONMENT: ${{ env.MODAL_ENVIRONMENT }}
          MODAL_TOKEN_ID: ${{ secrets.MODAL_TOKEN_ID }}
          MODAL_TOKEN_SECRET: ${{ secrets.MODAL_TOKEN_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          REPLICATE_API_TOKEN: ${{ secrets.REPLICATE_API_TOKEN }}
        run: |
          set -euo pipefail

          # Login to Modal
          modal token set --token-id "$MODAL_TOKEN_ID" --token-secret "$MODAL_TOKEN_SECRET" >/dev/null
          echo "üîê Syncing secrets to Modal env=$MODAL_ENVIRONMENT"

          # Get unique secret names from all processors
          SECRET_NAMES=$(echo '${{ steps.processors.outputs.list }}' | jq -r '.[].secrets[]?' | sort -u)

          # Sync each secret
          missing=()
          for name in $SECRET_NAMES; do
              case "$name" in
                  OPENAI_API_KEY)
                      val="$OPENAI_API_KEY"
                      ;;
                  REPLICATE_API_TOKEN)
                      val="$REPLICATE_API_TOKEN"
                      ;;
                  *)
                      echo "::warning::Unknown secret '$name' - add to allow-list"
                      val=""
                      ;;
              esac

              if [ -z "$val" ]; then
                  echo "‚ö†Ô∏è  Missing GitHub secret value: $name"
                  missing+=("$name")
                  continue
              fi

              echo "  Creating/updating $name (len=${#val})"
              modal secret create "$name" "$name=$val" --env "$MODAL_ENVIRONMENT" --force >/dev/null
          done

          if [ ${#missing[@]} -gt 0 ]; then
              echo "‚ùå Missing GitHub secret value(s): ${missing[*]}"
              exit 1
          fi

          echo "‚úÖ All required secrets synced to Modal"

      # 3) Deploy each processor to Modal
      - name: Deploy processors
        working-directory: code
        env:
          MODAL_ENVIRONMENT: ${{ env.MODAL_ENVIRONMENT }}
        run: |
          set -euo pipefail

          echo '${{ steps.processors.outputs.list }}' | jq -c '.[]' | while read -r processor; do
              ref=$(echo "$processor" | jq -r .ref)
              oci=$(echo "$processor" | jq -r .oci)
              secrets=$(echo "$processor" | jq -r '.secrets | join(",")')

              echo ""
              echo "üöÄ Deploying $ref"
              echo "   Image: $oci"
              echo "   Secrets: $secrets"

              # Set environment for this processor
              export PROCESSOR_REF="$ref"
              export IMAGE_REF="$oci"
              export TOOL_SECRETS="$secrets"

              # Deploy to Modal
              modal deploy --env "$MODAL_ENVIRONMENT" -m modal_app

              echo "‚úÖ Deployed $ref"
          done

      # 4) Post-deploy smoke tests (mode=mock) for each processor
      - name: Post-deploy smoke tests
        working-directory: code
        env:
          DJANGO_SETTINGS_MODULE: backend.settings.unittest
          MODAL_ENABLED: "true"
          MODAL_ENVIRONMENT: ${{ env.MODAL_ENVIRONMENT }}
        run: |
          set -euo pipefail

          echo '${{ steps.processors.outputs.list }}' | jq -c '.[]' | while read -r processor; do
              ref=$(echo "$processor" | jq -r .ref)

              echo ""
              echo "üß™ Smoke testing $ref (mode=mock)"

              # Determine test inputs based on processor family
              if [[ "$ref" == llm/* ]]; then
                  inputs='{"schema":"v1","model":"gpt-4o-mini","params":{"messages":[{"role":"user","content":"deployment smoke test"}]},"mode":"mock"}'
              elif [[ "$ref" == replicate/* ]]; then
                  inputs='{"schema":"v1","model":"black-forest-labs/flux-schnell","params":{"prompt":"test image"},"mode":"mock"}'
              else
                  echo "‚ö†Ô∏è Skipping unknown processor family: $ref"
                  continue
              fi

              # Run smoke test via Modal adapter
              result=$(python manage.py run_processor \
                  --ref "$ref" \
                  --adapter modal \
                  --mode mock \
                  --write-prefix "/artifacts/outputs/smoke/{execution_id}/" \
                  --inputs-json "$inputs" \
                  --json)

              # Validate response
              status=$(echo "$result" | jq -r .status)
              execution_id=$(echo "$result" | jq -r .execution_id)

              if [ "$status" != "success" ]; then
                  echo "‚ùå Smoke test failed for $ref"
                  echo "$result" | jq .
                  exit 1
              fi

              echo "‚úÖ $ref smoke passed: $execution_id"
          done

          echo ""
          echo "üéâ All processors deployed and smoke tested successfully"
