name: Main

on:
  push:
    branches: [main]
    paths:
      - "code/**"
      - "tools/**/registry.yaml"
      - ".github/workflows/main.yml"
      - "terraform/**"
      - "Makefile"
      - "Dockerfile"
  workflow_dispatch: {}

concurrency:
  group: main
  cancel-in-progress: true

env:
  APP_ENV: main

jobs:
  retag-django:
    name: Retag Django Image (main)
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Retag staging image as main
        run: |
          docker pull ghcr.io/veyorokon/theory-django:staging
          docker tag ghcr.io/veyorokon/theory-django:staging ghcr.io/veyorokon/theory-django:main
          docker push ghcr.io/veyorokon/theory-django:main

  provision:
    name: Provision Production Infrastructure
    needs: retag-django
    runs-on: ubuntu-latest
    environment: main
    timeout-minutes: 30
    env:
      TF_VAR_django_secret_key: ${{ secrets.DJANGO_SECRET_KEY }}
      TF_VAR_storage_access_key: ${{ secrets.SPACES_ACCESS_KEY_ID }}
      TF_VAR_storage_secret_key: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
      TF_VAR_django_image_tag: main
      TF_VAR_ghcr_token: ${{ secrets.GHCR_TOKEN }}
      DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
      SPACES_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
      SPACES_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.10.5"

      - name: Terraform Init
        working-directory: terraform/environments/main
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
        run: terraform init

      - name: Terraform Plan
        working-directory: terraform/environments/main
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: terraform/environments/main
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
        run: terraform apply -auto-approve tfplan

      - name: Get App URL
        id: app_url
        working-directory: terraform/environments/main
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
        run: |
          APP_URL=$(terraform output -raw app_url)
          echo "url=$APP_URL" >> $GITHUB_OUTPUT
          echo "üöÄ Production URL: $APP_URL"

    outputs:
      app_url: ${{ steps.app_url.outputs.url }}

  test-deployment:
    name: Test Production Deployment
    needs: provision
    runs-on: ubuntu-latest
    steps:
      - name: Wait for deployment
        run: |
          echo "Waiting for App Platform to deploy production..."
          sleep 90

      - name: Health check
        run: |
          APP_URL="${{ needs.provision.outputs.app_url }}"

          for i in {1..30}; do
            if curl -f "${APP_URL}/health/" 2>/dev/null; then
              echo "‚úÖ Production health check passed"
              exit 0
            fi
            echo "‚è≥ Waiting for production app... ($i/30)"
            sleep 10
          done

          echo "‚ùå Production health check failed"
          exit 1

      - name: Smoke tests
        run: |
          APP_URL="${{ needs.provision.outputs.app_url }}"

          # Test GraphQL endpoint
          RESPONSE=$(curl -s -X POST "${APP_URL}/graphql/" \
            -H "Content-Type: application/json" \
            -d '{"query": "{ __schema { queryType { name } } }"}')

          if echo "$RESPONSE" | grep -q "queryType"; then
            echo "‚úÖ GraphQL endpoint responding"
          else
            echo "‚ùå GraphQL endpoint failed"
            echo "$RESPONSE"
            exit 1
          fi

  test-modal:
    name: Test Modal Tools (Production)
    runs-on: ubuntu-latest
    environment: main
    env:
      DJANGO_SETTINGS_MODULE: backend.settings.production
      DJANGO_SECRET_KEY: test-key-for-ci
      DATABASE_URL: sqlite:////home/runner/work/theory-api/theory-api/code/test.db
      STORAGE_BACKEND: s3
      STORAGE_ACCESS_KEY: ${{ secrets.SPACES_ACCESS_KEY_ID }}
      STORAGE_SECRET_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
      ARTIFACTS_REGION: nyc3
      ARTIFACTS_ENDPOINT: https://nyc3.digitaloceanspaces.com
      ARTIFACTS_BUCKET: theory-artifacts-main
      ADAPTER: modal
      TEST_ADAPTER: modal
      PLATFORM: amd64
      APP_ENV: main
      MOCK_MISSING_SECRETS: "false"
      MODAL_TOKEN_ID: ${{ secrets.MODAL_TOKEN_ID }}
      MODAL_TOKEN_SECRET: ${{ secrets.MODAL_TOKEN_SECRET }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      REPLICATE_API_TOKEN: ${{ secrets.REPLICATE_API_TOKEN }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip
          cache-dependency-path: |
            requirements.txt
            requirements-dev.txt
      - run: pip install -r requirements.txt -r requirements-dev.txt
      - run: cd code && python manage.py migrate --noinput
      - run: cd code && python manage.py toolctl sync

      - name: Deploy tools to Modal
        run: make start-tools ADAPTER=modal

      - name: Run integration tests
        run: make test-integration
