"""Scaffold new processor with universal thin pattern."""

from __future__ import annotations
from django.core.management.base import BaseCommand, CommandError
from pathlib import Path

TEMPLATE_MAIN = '''"""Processor main entry point - generated by scaffold_processor."""
from __future__ import annotations
import json, os, sys, time
from pathlib import Path

from libs.runtime_common.processor import parse_args, load_inputs_json, ensure_write_prefix
from libs.runtime_common.hashing import inputs_hash
from libs.runtime_common.fingerprint import compose_env_fingerprint
from libs.runtime_common.outputs import write_outputs, write_outputs_index
from libs.runtime_common.receipts import write_dual_receipts
from apps.core.integrations.types import ProcessorResult, OutputItem


def process_inputs(inputs: dict) -> ProcessorResult:
    """Main processor logic - implement your processing here."""
    # TODO: Replace with actual processor logic
    example_text = f"Processed: {{inputs.get('input', 'no input')}}"
    output = OutputItem(
        relpath="outputs/result.txt",
        bytes_=example_text.encode("utf-8")
    )
    return ProcessorResult(
        outputs=[output],
        processor_info="{PROCESSOR_REF}",
        usage={{}},
        extra={{}}
    )


def main() -> int:
    """Universal thin processor main entry point."""
    args = parse_args()
    ensure_write_prefix(args.write_prefix)
    payload = load_inputs_json(args.inputs)

    # Canonical inputs hash
    ih = inputs_hash(payload)

    # Process inputs
    t0 = time.time()
    result = process_inputs(payload)
    duration_ms = int((time.time() - t0) * 1000)

    # Write outputs and index
    abs_paths = write_outputs(args.write_prefix, result.outputs)
    idx_path = write_outputs_index(
        execution_id=args.execution_id,
        write_prefix=args.write_prefix,
        paths=abs_paths
    )

    # Environment fingerprint
    env_fp = compose_env_fingerprint(
        image=os.getenv("IMAGE_REF", "unknown"),
        cpu=os.getenv("CPU", "1"),
        memory=os.getenv("MEMORY", "2Gi")
    )

    # Dual receipts
    receipt = {{
        "execution_id": args.execution_id,
        "processor_ref": "{PROCESSOR_REF}",
        "image_digest": os.getenv("IMAGE_REF", "unknown"),
        "env_fingerprint": env_fp,
        "inputs_hash": ih["value"],
        "hash_schema": ih["hash_schema"],
        "outputs_index": str(idx_path),
        "processor_info": result.processor_info,
        "usage": result.usage,
        "timestamp_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "duration_ms": duration_ms,
    }}
    write_dual_receipts(args.execution_id, args.write_prefix, receipt)

    # Optional CLI response
    resp_path = Path(args.write_prefix) / "response.json"
    resp_path.write_text(
        json.dumps({{
            "ok": True,
            "processor_info": result.processor_info,
            "outputs": [str(p) for p in abs_paths]
        }}, separators=(",", ":")),
        encoding="utf-8"
    )

    return 0


if __name__ == "__main__":
    sys.exit(main())
'''

TEMPLATE_DOCKERFILE = """FROM python:3.11-slim
WORKDIR /work
COPY requirements.txt /work/
RUN pip install --no-cache-dir -r requirements.txt
COPY . /work
ENTRYPOINT ["python", "-m", "apps.core.processors.{PROC_PKG}.main"]
"""

TEMPLATE_REQS = """blake3
# Add processor-specific dependencies here
"""

TEMPLATE_YAML = """ref: {NS}/{NAME}@{VER}
runtime:
  cpu: {CPU}
  memory: {MEM}
  gpu: {GPU}
image:
  oci: ghcr.io/{OWNER}/{NS}_{NAME}@sha256:pending
secrets:
  required:
{SECRETS}
policy:
  network: egress
  request_timeout_s: 120
"""


class Command(BaseCommand):
    help = "Scaffold a new processor with universal thin pattern"

    def add_arguments(self, parser):
        parser.add_argument("--ref", required=True, help="Processor ref (ns/name@ver)")
        parser.add_argument("--runtime", default="cpu=1,memory=2Gi,gpu=none")
        parser.add_argument("--secrets", default="", help="Comma-separated secret names")
        parser.add_argument("--owner", default="owner", help="Container registry owner")

    def handle(self, *args, **opts):
        ref = opts["ref"]
        try:
            ns, rest = ref.split("/", 1)
            name, ver = rest.split("@", 1)
        except ValueError:
            raise CommandError(f"Invalid ref format: {ref} (expected ns/name@ver)")

        pkg = f"{ns}_{name}"
        proc_dir = Path(f"apps/core/processors/{pkg}")
        proc_dir.mkdir(parents=True, exist_ok=True)

        # Parse runtime options
        cpu, mem, gpu = "1", "2Gi", "none"
        for kv in opts["runtime"].split(","):
            if "=" not in kv:
                continue
            k, v = kv.split("=", 1)
            if k == "cpu":
                cpu = v
            elif k == "memory":
                mem = v
            elif k == "gpu":
                gpu = v

        # Parse secrets
        secrets = [s.strip() for s in opts["secrets"].split(",") if s.strip()]
        if secrets:
            secrets_yaml = "\n".join([f"    - {s}" for s in secrets])
        else:
            secrets_yaml = "    # - SECRET_NAME"

        # Generate files
        main_src = TEMPLATE_MAIN.replace("{PROCESSOR_REF}", ref)
        (proc_dir / "main.py").write_text(main_src, encoding="utf-8")

        dockerfile_src = TEMPLATE_DOCKERFILE.replace("{PROC_PKG}", pkg)
        (proc_dir / "Dockerfile").write_text(dockerfile_src, encoding="utf-8")

        (proc_dir / "requirements.txt").write_text(TEMPLATE_REQS, encoding="utf-8")

        # Generate registry YAML
        yaml_path = Path(f"apps/core/registry/processors/{pkg}.yaml")
        yaml_path.parent.mkdir(parents=True, exist_ok=True)
        yaml_src = TEMPLATE_YAML.format(
            NS=ns, NAME=name, VER=ver, OWNER=opts["owner"], CPU=cpu, MEM=mem, GPU=gpu, SECRETS=secrets_yaml
        )
        yaml_path.write_text(yaml_src, encoding="utf-8")

        self.stdout.write(self.style.SUCCESS(f"âœ“ Scaffolded processor {ref} at {proc_dir}"))
        self.stdout.write(f"  Registry: {yaml_path}")
        self.stdout.write(f"  Main: {proc_dir}/main.py")
        self.stdout.write(f"  Container: {proc_dir}/Dockerfile")
